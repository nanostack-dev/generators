package generator

import (
	"fmt"
	"strings"

	"github.com/nanostack-dev/generators/internal/builder/parser"

	"github.com/dave/jennifer/jen"
)

// normalizeMethodName ensures consistent method name format for comparison
func normalizeMethodName(name string, prefix string) string {
	name = strings.ToLower(name)
	prefix = strings.ToLower(prefix)
	if strings.HasPrefix(name, strings.ToLower(prefix)) {
		return name
	}
	return prefix + name
}

func Generate(structDef *parser.StructDef, packageName string, outputFile string) error {
	if structDef == nil {
		return fmt.Errorf("structDef cannot be nil")
	}

	if structDef.Annotations.Skip {
		return nil
	}

	if packageName == "" {
		packageName = structDef.PackageStr
	}

	// Override package name if specified in annotations
	if structDef.Annotations.Package != "" {
		packageName = structDef.Annotations.Package
	}

	// Override output file if specified in annotations
	if structDef.Annotations.Output != "" {
		outputFile = strings.ReplaceAll(
			structDef.Annotations.Output, "{name}", strings.ToLower(structDef.Name),
		)
	}

	f := jen.NewFile(packageName)
	f.HeaderComment("Code generated by nanostack/generator; DO NOT EDIT.")

	// Add imports with proper handling for standard packages
	importAliases := make(map[string]string)
	for _, imp := range structDef.Imports {
		cleanPath := strings.Trim(imp, `"`)
		parts := strings.Split(cleanPath, "/")
		if len(parts) > 0 {
			pkgName := parts[len(parts)-1]
			importAliases[cleanPath] = pkgName
			fmt.Printf("Added import - Path: %s, Alias: %s\n", cleanPath, pkgName)
		}
	}

	fmt.Printf("Final importAliases map: %+v\n", importAliases)
	f.ImportNames(importAliases)

	builderName := structDef.Name + "Builder"

	// Generate builder struct
	f.Type().Id(builderName).Struct(
		jen.Id("instance").Op("*").Id(structDef.Name),
	)

	// Generate constructor
	constructorName := "New" + builderName
	if structDef.Annotations.Constructor != "" {
		constructorName = structDef.Annotations.Constructor
	}
	generateConstructor(f, builderName, structDef.Name, constructorName)

	// Generate ToBuilder method
	generateToBuilder(f, builderName, structDef)

	// Generate setter methods for each field
	prefix := structDef.Annotations.Prefix
	if prefix == "" {
		prefix = "With"
	}

	for _, field := range structDef.Fields {
		methodName := prefix + field.Name
		for _, customMethod := range structDef.Annotations.CustomMethods {
			if normalizeMethodName(methodName, prefix) == normalizeMethodName(
				customMethod, prefix,
			) {
				field.CustomGen = true
				break
			}
		}

		if !field.CustomGen {
			if structDef.Annotations.Immutable {
				generateCopyMethod(f, builderName, field, structDef.Name, importAliases)
			} else {
				generateWithMethod(f, builderName, field, structDef.Name, prefix, importAliases)
			}
		}
	}

	// Generate mapped methods
	for _, methodMap := range structDef.Annotations.MethodMaps {
		generateMappedMethod(f, builderName, methodMap.From, methodMap.To)
	}

	// Generate Build method
	f.Func().Params(
		jen.Id("b").Op("*").Id(builderName),
	).Id("Build").Params().Op("*").Id(structDef.Name).Block(
		jen.Return(jen.Id("b").Dot("instance")),
	)

	// Generate BuildAsPtr method
	f.Func().Params(
		jen.Id("b").Op("*").Id(builderName),
	).Id("BuildAsPtr").Params().Op("*").Id(structDef.Name).Block(
		jen.Return(jen.Id("b").Dot("instance")),
	)

	return f.Save(outputFile)
}

func generateMappedMethod(f *jen.File, builderName string, fromMethod, toMethod string) {
	f.Func().Params(
		jen.Id("b").Op("*").Id(builderName),
	).Id(fromMethod).Params().Op("*").Id(builderName).Block(
		jen.Return(jen.Id("b").Dot(toMethod).Call()),
	)
}

func generateFieldAssignments(
	fields []parser.StructField, importAliases map[string]string,
) []jen.Code {
	var statements []jen.Code
	for _, field := range fields {
		statements = append(statements, jen.Id(field.Name).Op(":").Id("p").Dot(field.Name))
	}
	return statements
}

func generateWithMethod(
	f *jen.File,
	builderName string,
	field parser.StructField,
	structName string,
	prefix string,
	importAliases map[string]string,
) {
	paramType := getQualifiedType(field.Type, importAliases)
	f.Func().Params(
		jen.Id("b").Op("*").Id(builderName),
	).Id(prefix+field.Name).Params(
		jen.Id(strings.ToLower(string(field.Name[0]))+field.Name[1:]).Add(paramType),
	).Op("*").Id(builderName).Block(
		jen.Id("b").Dot("instance").Dot(field.Name).Op("=").Id(strings.ToLower(field.Name)),
		jen.Return(jen.Id("b")),
	)
}

func generateCopyMethod(
	f *jen.File,
	builderName string,
	field parser.StructField,
	structName string,
	importAliases map[string]string,
) {
	paramType := getQualifiedType(field.Type, importAliases)
	f.Func().Params(
		jen.Id("b").Op("*").Id(builderName),
	).Id("With"+field.Name).Params(
		jen.Id(strings.ToLower(field.Name)).Add(paramType),
	).Op("*").Id(builderName).Block(
		jen.Id("newInstance").Op(":=").Op("*").Id("b").Dot("instance"),
		jen.Id("newInstance").Dot(field.Name).Op("=").Id(strings.ToLower(field.Name)),
		jen.Return(
			jen.Op("&").Id(builderName).Values(
				jen.Id("instance").Op(":").Op("&").Id("newInstance"),
			),
		),
	)
}

func generateConstructor(f *jen.File, builderName, structName, constructorName string) {
	f.Func().Id(constructorName).Params().Op("*").Id(builderName).Block(
		jen.Return(
			jen.Op("&").Id(builderName).Values(
				jen.Id("instance").Op(":").Op("&").Id(structName).Values(),
			),
		),
	)
}

func generateToBuilder(f *jen.File, builderName string, structDef *parser.StructDef) {
	f.Func().Params(
		jen.Id("p").Op("*").Id(structDef.Name),
	).Id("ToBuilder").Params().Op("*").Id(builderName).Block(
		jen.If(jen.Id("p").Op("==").Nil()).Block(
			jen.Return(jen.Id("New"+builderName).Call()),
		),
		jen.Return(
			jen.Op("&").Id(builderName).Values(
				jen.Id("instance").Op(":").Op("&").Id(structDef.Name).Values(
					generateFieldAssignments(structDef.Fields, nil)...,
				),
			),
		),
	)
}

// getQualifiedType returns a jen.Code for the type, handling package qualification
func getQualifiedType(fieldType string, importAliases map[string]string) *jen.Statement {
	// Handle slice types
	if strings.HasPrefix(fieldType, "[]") {
		return jen.Index().Add(getQualifiedType(fieldType[2:], importAliases))
	}

	// Handle pointer types
	if strings.HasPrefix(fieldType, "*") {
		return jen.Op("*").Add(getQualifiedType(fieldType[1:], importAliases))
	}

	// Handle package qualified types (e.g., time.Time, uuid.UUID)
	if strings.Contains(fieldType, ".") {
		parts := strings.SplitN(fieldType, ".", 2)
		pkg := parts[0]
		typeName := parts[1]

		// Find the import path for the package
		for importPath, alias := range importAliases {
			if alias == pkg {
				return jen.Qual(importPath, typeName)
			}
		}
	}

	// Default case for basic types
	return jen.Id(fieldType)
}
