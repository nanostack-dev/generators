// generator.go
package generator

import (
	"fmt"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/nanostack-dev/generators/builder/internal/parser"
)

func Generate(structDef *parser.StructDef, packageName string, outputFile string) error {
	if structDef == nil {
		return fmt.Errorf("structDef cannot be nil")
	}

	if structDef.Annotations.Skip {
		return nil
	}

	if packageName == "" {
		packageName = structDef.PackageStr
	}

	prefix := "With"
	if structDef.Annotations.Prefix != "" {
		prefix = structDef.Annotations.Prefix
	}

	f := jen.NewFile(packageName)
	f.HeaderComment("Code generated by nanostack/generator; DO NOT EDIT.")

	builderName := structDef.Name + "Builder"

	// Generate builder struct
	f.Type().Id(builderName).Struct(
		jen.Id("instance").Op("*").Id(structDef.Name),
	)

	// Generate constructor
	generateConstructor(f, builderName, structDef.Name)

	// Generate ToBuilder method
	generateToBuilder(f, builderName, structDef)

	// Generate setter methods for each field
	for _, field := range structDef.Fields {
		generateWithMethod(f, builderName, field, structDef.Name, prefix)
	}

	// Generate Build method
	f.Func().Params(
		jen.Id("b").Op("*").Id(builderName),
	).Id("Build").Params().Op("*").Id(structDef.Name).Block(
		jen.Return(jen.Id("b").Dot("instance")),
	)

	return f.Save(outputFile)
}

func generateFieldAssignments(fields []parser.StructField) []jen.Code {
	var statements []jen.Code
	for _, field := range fields {
		statements = append(statements, jen.Id(field.Name).Op(":").Id("p").Dot(field.Name))
	}
	return statements
}

func lowerFirst(s string) string {
	if len(s) == 0 {
		return s
	}
	return fmt.Sprintf("%c%s", s[0]|32, s[1:])
}

func generateWithMethod(
	f *jen.File, builderName string, field parser.StructField, structName, prefix string,
) {
	f.Func().Params(
		jen.Id("b").Op("*").Id(builderName),
	).Id(prefix+field.Name).Params(
		jen.Id(strings.ToLower(field.Name)).Id(field.Type),
	).Op("*").Id(builderName).Block(
		jen.Id("b").Dot("instance").Dot(field.Name).Op("=").Id(strings.ToLower(field.Name)),
		jen.Return(jen.Id("b")),
	)
}

func generateConstructor(f *jen.File, builderName, structName string) {
	f.Func().Id("New" + builderName).Params().Op("*").Id(builderName).Block(
		jen.Return(
			jen.Op("&").Id(builderName).Values(
				jen.Id("instance").Op(":").Op("&").Id(structName).Values(),
			),
		),
	)
}

func generateToBuilder(f *jen.File, builderName string, structDef *parser.StructDef) {
	f.Func().Params(
		jen.Id("p").Op("*").Id(structDef.Name),
	).Id("ToBuilder").Params().Op("*").Id(builderName).Block(
		jen.If(jen.Id("p").Op("==").Nil()).Block(
			jen.Return(jen.Id("New"+builderName).Call()),
		),
		jen.Return(
			jen.Op("&").Id(builderName).Values(
				jen.Id("instance").Op(":").Op("&").Id(structDef.Name).Values(
					generateFieldAssignments(structDef.Fields)...,
				),
			),
		),
	)
}
